/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package org.dethware.xmpp.client;

import java.awt.Color;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.text.DateFormat;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.*;

/**
 *
 * @author peterix
 */
public class ConversationPanel extends javax.swing.JPanel implements ConversationListener {

    private Conversation myConversation;
    private int index;
    private StyledDocument doc;
    private Style defaultStyle;
    private Style outStyle;
    private Style outStyleBold;
    private Style inStyle;
    private Style inStyleBold;
    /**
     * Creates new form ConversationPanel
     */
    public ConversationPanel( Conversation conv, int index ) {
        myConversation = conv;
        this.index = index;
        initComponents();
        doc = historyPane.getStyledDocument();
        
        // styles for message formatting
        defaultStyle = doc.addStyle("normal",null);
        StyleConstants.setFontSize(defaultStyle, 14);
        
        inStyle = doc.addStyle("in",defaultStyle);
        StyleConstants.setForeground(inStyle, Color.blue);
        
        inStyleBold = doc.addStyle("in_bold", inStyle);
        StyleConstants.setBold(inStyleBold, true);
        
        outStyle = doc.addStyle("out", defaultStyle);
        StyleConstants.setForeground(outStyle, Color.red);
        
        outStyleBold = doc.addStyle("out_bold", outStyle);
        StyleConstants.setBold(outStyleBold, true);
        
        displayOldMessages();
        conv.addConversationListener(this);
        messageArea.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyPressed(KeyEvent e)
            {
                if (e.getKeyCode() == KeyEvent.VK_ENTER && 
                    !e.isControlDown() && !e.isShiftDown())
                {
                    sendCurrentText();
                    e.consume();
                }
            }
        });
    }

    private void printMessageToLog(ConversationEntry ce)
    {
        String who = "Me";
        if(!ce.isSent())
        {
            who = myConversation.getContact().getName();
        }
        long unixtime =  ce.getUnixTimestampCreated();
        Date created = new Date(unixtime * 1000);
        String DateTime = DateFormat.getTimeInstance().format(created);

        if(ce.isHistorical())
        {
            try {
                doc.insertString(doc.getLength(), "" + DateTime + " " + who + " : " + ce.getBody() + "\n", defaultStyle);
            } catch (BadLocationException ex) {
                Logger.getLogger(ConversationPanel.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        else
        {
            Style BoldStyle;
            Style NormalStyle;
            if(ce.isSent())
            {
                BoldStyle = outStyleBold;
                NormalStyle = outStyle;
            }
            else
            {
                BoldStyle = inStyleBold;
                NormalStyle = inStyle;
            }
            try {
                doc.insertString(doc.getLength(), "(" + DateTime + ") ", NormalStyle);
                doc.insertString(doc.getLength(), who + ": ", BoldStyle);
                doc.insertString(doc.getLength(), ce.getBody() + "\n", defaultStyle);
            } catch (BadLocationException ex) {
                Logger.getLogger(ConversationPanel.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    
    private void displayOldMessages()
    {
        boolean siftHistory = true;
        List<ConversationEntry> entryList = myConversation.acquireMessagesForPanel();
        for(ConversationEntry ce:entryList)
        {
            if(siftHistory && !ce.isHistorical())
            {
                siftHistory = false;
                // print <hr/> here
            }
            printMessageToLog(ce);
        }
        myConversation.markAllMessagesAsHistory();
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        historyScroller = new javax.swing.JScrollPane();
        historyPane = new javax.swing.JTextPane();
        messageScroller = new javax.swing.JScrollPane();
        messageArea = new javax.swing.JTextArea();
        sendButton = new javax.swing.JButton();

        historyPane.setContentType("text/html");
        historyPane.setEditable(false);
        historyScroller.setViewportView(historyPane);

        messageArea.setColumns(20);
        messageArea.setRows(5);
        messageScroller.setViewportView(messageArea);

        sendButton.setText("Send");
        sendButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sendButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(messageScroller, javax.swing.GroupLayout.DEFAULT_SIZE, 423, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(sendButton))
            .addComponent(historyScroller)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(historyScroller, javax.swing.GroupLayout.DEFAULT_SIZE, 396, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(messageScroller)
                    .addComponent(sendButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void sendButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sendButtonActionPerformed
        sendCurrentText();
    }//GEN-LAST:event_sendButtonActionPerformed

    private void sendCurrentText()
    {
        String msgText = messageArea.getText();
        // check if the message isn't just empty
        String msgTrimmed = msgText.trim();
        if(!msgTrimmed.equals(""))
        {
            boolean successful = myConversation.sendMessage(messageArea.getText());
            if(successful)
            {
                messageArea.setText("");
            }
        }
        else
        {
            messageArea.setText("");
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextPane historyPane;
    private javax.swing.JScrollPane historyScroller;
    private javax.swing.JTextArea messageArea;
    private javax.swing.JScrollPane messageScroller;
    private javax.swing.JButton sendButton;
    // End of variables declaration//GEN-END:variables

    /**
     * @return the index
     */
    public int getIndex() {
        return index;
    }

    /**
     * @param index the index to set
     */
    public void setIndex(int index) {
        this.index = index;
    }

    @Override
    public void messageReceived(Conversation conversation, ConversationEntry message) {
        printMessageToLog(message);
    }

    @Override
    public void messageSent(Conversation conversation, ConversationEntry message) {
        printMessageToLog(message);
    }
}
